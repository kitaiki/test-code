<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê°„ë‹¨í•œ Polygon Split ì˜ˆì œ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        canvas {
            border: 2px solid #333;
            background-color: #f8f9fa;
            cursor: crosshair;
            display: block;
            margin: 20px auto;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 12px 24px;
            background-color: #007cba;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }
        button:hover {
            background-color: #005a87;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .info {
            background-color: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }
        .legend {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .legend-color {
            width: 24px;
            height: 24px;
            border: 2px solid #333;
            border-radius: 4px;
        }
        .status {
            text-align: center;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }
        .result {
            background-color: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4caf50;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; color: #333;">Polygonì„ Lineìœ¼ë¡œ ë¶„í• í•˜ê¸°</h1>
        
        <div class="info">
            <h3>ğŸ¯ ì‚¬ìš©ë²•:</h3>
            <ol>
                <li><strong>í´ë¦¬ê³¤ ìƒì„±</strong>: ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ ë‹¤ê°í˜•ì˜ ê¼­ì§“ì ì„ ë§Œë“¤ê³ , ì‹œì‘ì ì„ ë‹¤ì‹œ í´ë¦­í•´ì„œ í´ë¦¬ê³¤ì„ ì™„ì„±í•˜ì„¸ìš”</li>
                <li><strong>ë¶„í• ì„  ê·¸ë¦¬ê¸°</strong>: í´ë¦¬ê³¤ì„ ê°€ë¡œì§€ë¥´ëŠ” ì§ì„ ì„ ê·¸ìœ¼ì„¸ìš” (ì‹œì‘ì ê³¼ ëì  í´ë¦­)</li>
                <li><strong>ë¶„í•  ì‹¤í–‰</strong>: ìë™ìœ¼ë¡œ í´ë¦¬ê³¤ì´ ë‘ ê°œë¡œ ë¶„í• ë©ë‹ˆë‹¤</li>
                <li><strong>ì´ˆê¸°í™”</strong>: ëª¨ë“  ë„í˜•ì„ ì§€ìš°ê³  ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤</li>
            </ol>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(255, 0, 0, 0.3); border-color: red;"></div>
                <span>ì›ë³¸ í´ë¦¬ê³¤</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: blue;"></div>
                <span>ë¶„í• ì„ </span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(0, 255, 0, 0.3); border-color: green;"></div>
                <span>ë¶„í• ëœ ì˜ì—­ 1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: rgba(255, 165, 0, 0.3); border-color: orange;"></div>
                <span>ë¶„í• ëœ ì˜ì—­ 2</span>
            </div>
        </div>

        <div class="controls">
            <button id="drawPolygon">í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°</button>
            <button id="drawLine" disabled>ë¶„í• ì„  ê·¸ë¦¬ê¸°</button>
            <button id="splitPolygon" disabled>ë¶„í•  ì‹¤í–‰</button>
            <button id="clear">ì´ˆê¸°í™”</button>
        </div>

        <div class="status" id="status">í´ë¦¬ê³¤ ê·¸ë¦¬ê¸° ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì‹œì‘í•˜ì„¸ìš”</div>

        <canvas id="canvas" width="800" height="600"></canvas>
        
        <div id="result" class="result">
            <h3>âœ… ê²°ê³¼:</h3>
            <p id="resultText"></p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const resultDiv = document.getElementById('result');
        const resultText = document.getElementById('resultText');

        // ë²„íŠ¼ë“¤
        const drawPolygonBtn = document.getElementById('drawPolygon');
        const drawLineBtn = document.getElementById('drawLine');
        const splitPolygonBtn = document.getElementById('splitPolygon');
        const clearBtn = document.getElementById('clear');

        // ìƒíƒœ ê´€ë¦¬
        let mode = 'none'; // 'polygon', 'line', 'none'
        let polygon = [];
        let splitLine = null;
        let splitPolygons = [];
        let isDrawingPolygon = false;
        let isDrawingLine = false;
        let lineStart = null;

        // ê¸°í•˜í•™ì  ê³„ì‚° í•¨ìˆ˜ë“¤
        function pointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function lineIntersection(p1, p2, p3, p4) {
            const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (Math.abs(denom) < 1e-10) return null;

            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;

            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
            }
            return null;
        }

        function getPolygonLineIntersections(polygon, line) {
            const intersections = [];
            
            // í´ë¦¬ê³¤ì˜ ëª¨ë“  ì—£ì§€ ê²€ì‚¬ (ë§ˆì§€ë§‰ ì ê³¼ ì²« ë²ˆì§¸ ì  ì—°ê²° í¬í•¨)
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length]; // ë§ˆì§€ë§‰ ì ì€ ì²« ë²ˆì§¸ ì ê³¼ ì—°ê²°
                
                const intersection = lineIntersection(p1, p2, line.start, line.end);
                if (intersection) {
                    // ì¤‘ë³µ êµì°¨ì  ì œê±° (ê°™ì€ ìœ„ì¹˜ì˜ ì ë“¤)
                    const isDuplicate = intersections.some(existing => 
                        distance(existing.point, intersection) < 5
                    );
                    
                    if (!isDuplicate) {
                        intersections.push({
                            point: intersection,
                            edgeIndex: i,
                            edgeStart: p1,
                            edgeEnd: p2
                        });
                    }
                }
            }
            return intersections;
        }

        function splitPolygonByLine(polygon, line) {
            const intersections = getPolygonLineIntersections(polygon, line);
            
            console.log('êµì°¨ì  ê°œìˆ˜:', intersections.length);
            console.log('êµì°¨ì ë“¤:', intersections);
            
            if (intersections.length < 2) {
                console.log('êµì°¨ì ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ë¶„í• ì„ ì´ í´ë¦¬ê³¤ì„ ì™„ì „íˆ ê°€ë¡œì§€ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return null;
            }
            
            if (intersections.length > 2) {
                console.log('êµì°¨ì ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ê°€ì¥ ì ì ˆí•œ 2ê°œë§Œ ì„ íƒí•©ë‹ˆë‹¤.');
                // ë¶„í• ì„  ìƒì—ì„œ ê°€ì¥ ë¨¼ 2ê°œ ì  ì„ íƒ
                intersections.sort((a, b) => {
                    const distA = distance(line.start, a.point);
                    const distB = distance(line.start, b.point);
                    return distA - distB;
                });
                intersections.splice(2); // ì²˜ìŒ 2ê°œë§Œ ìœ ì§€
            }

            // êµì°¨ì ì„ ì—£ì§€ ì¸ë±ìŠ¤ ìˆœìœ¼ë¡œ ì •ë ¬
            intersections.sort((a, b) => a.edgeIndex - b.edgeIndex);
            
            const [int1, int2] = intersections;
            
            console.log('ì„ íƒëœ êµì°¨ì :', int1, int2);

            // ë‘ ê°œì˜ ìƒˆë¡œìš´ í´ë¦¬ê³¤ ìƒì„±
            const poly1 = [];
            const poly2 = [];

            // ì²« ë²ˆì§¸ í´ë¦¬ê³¤: ì‹œì‘ë¶€í„° ì²« ë²ˆì§¸ êµì°¨ì ê¹Œì§€, ê·¸ë¦¬ê³  ë‘ ë²ˆì§¸ êµì°¨ì ë¶€í„° ëê¹Œì§€
            for (let i = 0; i <= int1.edgeIndex; i++) {
                poly1.push(polygon[i]);
            }
            poly1.push(int1.point);
            poly1.push(int2.point);
            
            for (let i = int2.edgeIndex + 1; i < polygon.length; i++) {
                poly1.push(polygon[i]);
            }

            // ë‘ ë²ˆì§¸ í´ë¦¬ê³¤: ì²« ë²ˆì§¸ êµì°¨ì ë¶€í„° ë‘ ë²ˆì§¸ êµì°¨ì ê¹Œì§€
            poly2.push(int1.point);
            for (let i = int1.edgeIndex + 1; i <= int2.edgeIndex; i++) {
                poly2.push(polygon[i]);
            }
            poly2.push(int2.point);

            console.log('ë¶„í• ëœ í´ë¦¬ê³¤ 1:', poly1);
            console.log('ë¶„í• ëœ í´ë¦¬ê³¤ 2:', poly2);

            return [poly1, poly2];
        }

        function distance(p1, p2) {
            return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
        }

        // ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawPolygonShape(points, fillColor, strokeColor, lineWidth = 2) {
            if (points.length < 3) return;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        function drawLine(start, end, color = 'blue', lineWidth = 3) {
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        function drawPoint(point, color = 'black', radius = 4) {
            ctx.beginPath();
            ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
        }

        function render() {
            clearCanvas();

            // ë¶„í• ëœ í´ë¦¬ê³¤ë“¤ ê·¸ë¦¬ê¸°
            if (splitPolygons.length > 0) {
                const colors = [
                    { fill: 'rgba(0, 255, 0, 0.3)', stroke: 'green' },
                    { fill: 'rgba(255, 165, 0, 0.3)', stroke: 'orange' }
                ];
                splitPolygons.forEach((poly, index) => {
                    const color = colors[index % colors.length];
                    drawPolygonShape(poly, color.fill, color.stroke, 3);
                });
            } else if (polygon.length > 2) {
                // ì›ë³¸ í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°
                drawPolygonShape(polygon, 'rgba(255, 0, 0, 0.3)', 'red');
            }

            // ê·¸ë¦¬ëŠ” ì¤‘ì¸ í´ë¦¬ê³¤ì˜ ì ë“¤
            if (isDrawingPolygon) {
                polygon.forEach(point => drawPoint(point, 'red'));
                if (polygon.length > 0) {
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(polygon[0].x, polygon[0].y);
                    for (let i = 1; i < polygon.length; i++) {
                        ctx.lineTo(polygon[i].x, polygon[i].y);
                    }
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // ë¶„í• ì„  ê·¸ë¦¬ê¸°
            if (splitLine) {
                drawLine(splitLine.start, splitLine.end, 'blue', 4);
                drawPoint(splitLine.start, 'blue');
                drawPoint(splitLine.end, 'blue');
            }

            // ê·¸ë¦¬ëŠ” ì¤‘ì¸ ë¶„í• ì„ 
            if (isDrawingLine && lineStart) {
                drawPoint(lineStart, 'blue');
            }
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const point = { x, y };

            if (mode === 'polygon') {
                if (polygon.length > 2 && distance(point, polygon[0]) < 15) {
                    // í´ë¦¬ê³¤ ì™„ì„±
                    isDrawingPolygon = false;
                    drawLineBtn.disabled = false;
                    drawPolygonBtn.disabled = true;
                    status.textContent = 'í´ë¦¬ê³¤ì´ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ë¶„í• ì„ ì„ ê·¸ë ¤ì£¼ì„¸ìš”.';
                    mode = 'none';
                } else {
                    polygon.push(point);
                    if (polygon.length === 1) {
                        status.textContent = 'ê³„ì† í´ë¦­í•´ì„œ í´ë¦¬ê³¤ì„ ê·¸ë¦¬ê³ , ì‹œì‘ì ì„ ë‹¤ì‹œ í´ë¦­í•´ì„œ ì™„ì„±í•˜ì„¸ìš”.';
                    }
                }
            } else if (mode === 'line') {
                if (!lineStart) {
                    lineStart = point;
                    status.textContent = 'ë¶„í• ì„ ì˜ ëì ì„ í´ë¦­í•˜ì„¸ìš”.';
                } else {
                    splitLine = { start: lineStart, end: point };
                    lineStart = null;
                    isDrawingLine = false;
                    splitPolygonBtn.disabled = false;
                    drawLineBtn.disabled = true;
                    status.textContent = 'ë¶„í•  ì‹¤í–‰ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.';
                    mode = 'none';
                }
            }

            render();
        });

        // ë²„íŠ¼ ì´ë²¤íŠ¸ë“¤
        drawPolygonBtn.addEventListener('click', function() {
            mode = 'polygon';
            isDrawingPolygon = true;
            polygon = [];
            splitPolygons = [];
            splitLine = null;
            status.textContent = 'ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•´ì„œ í´ë¦¬ê³¤ì˜ ê¼­ì§“ì ì„ ë§Œë“œì„¸ìš”.';
            drawLineBtn.disabled = true;
            splitPolygonBtn.disabled = true;
            resultDiv.style.display = 'none';
            render();
        });

        drawLineBtn.addEventListener('click', function() {
            mode = 'line';
            isDrawingLine = true;
            lineStart = null;
            status.textContent = 'ë¶„í• ì„ ì˜ ì‹œì‘ì ì„ í´ë¦­í•˜ì„¸ìš”.';
            splitPolygonBtn.disabled = true;
        });

        splitPolygonBtn.addEventListener('click', function() {
            if (polygon.length > 2 && splitLine) {
                console.log('ë¶„í•  ì‹œë„ ì¤‘...');
                console.log('í´ë¦¬ê³¤:', polygon);
                console.log('ë¶„í• ì„ :', splitLine);
                
                const result = splitPolygonByLine(polygon, splitLine);
                if (result && result.length === 2 && result[0].length >= 3 && result[1].length >= 3) {
                    splitPolygons = result;
                    resultText.textContent = `í´ë¦¬ê³¤ì´ ${result.length}ê°œë¡œ ì„±ê³µì ìœ¼ë¡œ ë¶„í• ë˜ì—ˆìŠµë‹ˆë‹¤! (í´ë¦¬ê³¤1: ${result[0].length}ê°œ ì , í´ë¦¬ê³¤2: ${result[1].length}ê°œ ì )`;
                    resultDiv.style.display = 'block';
                    status.textContent = 'ë¶„í•  ì™„ë£Œ! ìƒˆë¡œìš´ í´ë¦¬ê³¤ì„ ë§Œë“¤ê±°ë‚˜ ì´ˆê¸°í™”í•˜ì„¸ìš”.';
                    splitPolygonBtn.disabled = true;
                    drawPolygonBtn.disabled = false;
                } else {
                    console.log('ë¶„í•  ì‹¤íŒ¨:', result);
                    alert('ë¶„í• ì„ ì´ í´ë¦¬ê³¤ì„ ì •í™•íˆ ê°€ë¡œì§€ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\níŒ:\n- ë¶„í• ì„ ì´ í´ë¦¬ê³¤ì˜ ê²½ê³„ì„ ê³¼ ì •í™•íˆ 2ê°œì˜ ì ì—ì„œ ë§Œë‚˜ì•¼ í•©ë‹ˆë‹¤\n- ë¶„í• ì„ ì´ í´ë¦¬ê³¤ì„ ì™„ì „íˆ ê´€í†µí•´ì•¼ í•©ë‹ˆë‹¤\n- ê¼­ì§“ì ì´ ì•„ë‹Œ ë³€ì˜ ì¤‘ê°„ ë¶€ë¶„ì„ ì§€ë‚˜ê°€ë„ë¡ ê·¸ë ¤ë³´ì„¸ìš”');
                    status.textContent = 'ë¶„í•  ì‹¤íŒ¨. ë¶„í• ì„ ì´ í´ë¦¬ê³¤ì˜ ë³€ì„ 2ê³³ì—ì„œ ê°€ë¡œì§€ë¥´ë„ë¡ ë‹¤ì‹œ ê·¸ë ¤ì£¼ì„¸ìš”.';
                    drawLineBtn.disabled = false;
                    splitLine = null;
                }
                render();
            }
        });

        clearBtn.addEventListener('click', function() {
            polygon = [];
            splitLine = null;
            splitPolygons = [];
            lineStart = null;
            mode = 'none';
            isDrawingPolygon = false;
            isDrawingLine = false;
            
            drawPolygonBtn.disabled = false;
            drawLineBtn.disabled = true;
            splitPolygonBtn.disabled = true;
            
            status.textContent = 'ëª¨ë“  ê²ƒì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. í´ë¦¬ê³¤ ê·¸ë¦¬ê¸°ë¥¼ ì‹œì‘í•˜ì„¸ìš”.';
            resultDiv.style.display = 'none';
            render();
        });

        // ì´ˆê¸° ë Œë”ë§
        render();
    </script>
</body>
</html>